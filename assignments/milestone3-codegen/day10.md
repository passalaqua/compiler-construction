# Day 10: Simple Code Generation

In this lab, you develop a simple code generator, that generates Java bytecode from simple MiniJava programs, which only print integer constants in their main methods.

## Overview

### Objectives

1. Write a Jasmin program which prints `42`.
2. Implement a code generator that transforms MiniJava programs into Java bytecode.
The code generator should include
    1. A transformation from MiniJava ASTs to Jasmin ASTs which handles 
        * MiniJava programs 
        * with only a main class 
        * with a single print statement with
        * an integer constant expression.
    2. A menu action which invokes the transformation and pretty-prints the Jasmin AST to concrete syntax.
    3. A menu action which generates a Java class file instead of a Jasmin file.
    4. A menu action which runs the program (challenge).

### Submission

You need to submit your MiniJava project on Blackboard. As part of your submission, we ask you to provide a short paragraph explaining the organisation of your Stratego files. The deadline for submission is December 11, 17:59.

### Grading

You can earn up to 10 points for your Jasmin program and up to 75 points for your code generator:

* transformation (50 points)
    * program (2 points)
    * main class (18 points)
    * main method (13 points)
    * print statement (17 points)
* menu actions (15 points)
    * Jasmin (5 points)
    * Java class file (10 points)
* challenges (10 points)
    * target directories (4 points)
    * runner (6 points)

You can earn up to 5 points for the organisation of your Stratego files and up to 10 points for the quality of your code. We focus on readability in general, meaningful variable names and the consistent use of Stratego paradigms. 
We will consider the fact that Stratego is new to you.

## Detailed Instructions

### Write Jasmin Code

Consider the following simple MiniJava program:

    class Main {
        public static void main(String[] args) {
            System.out.println(42);
        }
    }

Write a Jasmin program `simple.j`, which you expect to be the result of a MiniJava-to-Jasmin compiler. 
Generate a Java class file from it and run it. 
Improve your program until it runs without errors.

### Integrate Code Generation into the Editor

Code generation should be a service of your MiniJava editor. To achieve this, define a new menu entry *Generate Java bytecode* and associate it with a strategy `generate-jbc`. Implement this strategy in Stratego by following the interface for action strategies:

    generate-jbc: (selected, position, ast, path, project-path) -> (filename, result)

The implementation  should rely on a strategy `program-to-jbc`, which transforms MiniJava programs into Java bytecode. 

### Implement a Code Generation Strategy

Next, you need to implement `program-to-jbc`. 
You will do this stepwise over the remaining labs. 
During this lab, you should implement it for programs that contain only a main class, which prints a single integer constant. 
To understand Jasmin's abstract syntax, you can either
  study example ASTs generated by a Jasmin editor, 
  study the grammar in the Jasmin project, 
  or have a closer look into `lib/jasmin/JasminXT.str`.

1. The initial project contains already a rule for `exp-to-jbc`, which translates an integer constant from MiniJava into a sequence of Java bytecode instructions, that loads this constant to the operand stack. 
   Note that it is important to generate a sequence here, even if you only need a single instruction, because in general a MiniJava expression translates into a sequence of bytecode instructions.

2. Provide a rule for `stmt-to-jbc`, which translates a print statement from MiniJava into a sequence of Java bytecode instructions. 
This rule should call `exp-to-jbc` to translate the expression inside the print statement to a Java bytecode sequence. 

3. Provide a rule for `class-to-jbc`, which translates a main class from MiniJava into a Jasmin class file. 
This rule should call `stmt-to-jbc` to translate the statement inside the main method to a Java bytecode sequence.

4. Provide a rule for `program-to-jbc`, which translates a MiniJava program into a list of Jasmin class files. 
This rule should call `class-to-jbc` to translate the main class of the program into a Jasmin class file.

#### Testing

For testing purposes, you can define another menu entry which calls a strategy `to-jbc`, which dispatches to your different implementation rules:

    to-jbc = program-to-jbc + class-to-jbc + stmt-to-jbc + exp-to-jbc
    
This allows you to test your implementation by selecting a code fragment in the MiniJava editor and running your code generation builder.

#### Some Notes on Sequences

You can represent sequences as lists. 
Sequences of bytecode instructions are never nested. 
Thus, your generated sequences should also be flat lists. 
This requires you to compose sequences from recursive calls with surrounding instructions.
In general, there are four different approaches to this in Stratego:

1. Generate nested lists and flatten these lists afterwards by applying `flatten-list` (not recommended).

2. Compose lists with a head and tails notation. For example, `seq` might be a sequence generated by a recursive call. You can precede this sequence with instructions `instr1`, ..., `instrn` by writing `[ instr1, ..., instrn | seq ]`. 

3. Compose lists explicitly. 
    * `<conc> (l1, l2)` concatenates two lists `l1`and `l2`.
    * `<concat> [l1, ..., ln]` concatenates lists `l1` ... `ln`.  

4. Use special list variables (recommended). Stratego provides special variable names for sequences. These names end in `*`, for example `instr*`. When using such variables in a list, Stratego will inline the list elements at that position instead of creating a nested list. For example, 

        instr1* := [LDC("1"), LDC("2")]; instr2* := [LDC("0"), instr1*, LDC("3")]

    is equivalent to

        instr1* := [LDC("1"), LDC("2")]; instr2* := [LDC("0"), LDC("1"), LDC("2"), LDC("3")]

#### Generate Concrete Syntax

As you may have noticed, your implementation follows the code generation by transformation paradigm. The result of `to-jbc` is a Jasmin AST. Extend your builder strategy `generate-jbc` to generate concrete syntax. Therefor, you need to pretty-print the Jasmin ASTs, which are generated by `program-to-jbc`. You can find a pretty-printing strategy for Jasmin in `lib/jasmin/JasminXT-pp.str`.

### Generate Java Class Files

At this point, you can generate Jasmin class files from simple MiniJava programs. To run your programs in the Java Virtual Machine, you need to generate Java class files.
Define a new builder *Generate Java class files* with corresponding builder strategy, that generates the Jasmin file and turns it into a Java class file. To generate the class file, you first need to generate the Jasmin file.  Therefor, you need to create and write the file on your own. Implement a strategy `write-file` that rewrites a pair of file name and file content to itself. As a side effect, this strategy should create (if necessary) and write a file. These strategies might be useful: 

* `<fopen> (filename, "w")` opens a file for writing and gives you a file descriptor of the open file.
* `<fputs> (content, filedescriptor)` writes to a file.
* `<fclose> filedescriptor` closes a file.
* `<refresh-workspace-file> filename` refreshes a file in the Eclipse workspace. 

To figure out how to translate a Jasmin file into a Java class file, inspect the corresponding builder in the Jasmin project.

## Challenges

Challenges are meant to distinguish excellent solutions from good solutions. Typically, they are less guided and require more investigation and programming skills.

### Target Directories

Real-world compilers like the JDT place generated code in designated directories, such as `bin/` or `src-gen/`. Implement a similar behaviour for your MiniJava compiler. Make sure you can handle classes with the same name from different programs and files with the same name from different directories.

The following strategies deal with directories:

* `<file-exists ; filemode ; isdir> path` succeeds if `path` is a path to an existing directory in the file system.
* `<mkdir> path` creates a new directory.

### Automatic Code Generation

Real-world compilers like the JDT generate code silently in the background. Implement a similar behaviour, using Spoofax's `on-save` builder. In your main Stratego file, change `editor-save` to run your compiler: `editor-save = where(analysis-save-default(|<language>)); generate-java-class-files`. `editor-save` has the same input interface as a builder, but the output should be `None()`. This means that you cannot return a `(filename, result)` tuple like a normal builder, but need to write to a file yourself.

### Run a MiniJava Program

Add a builder that runs a MiniJava program by running the main method from the generated class file.

